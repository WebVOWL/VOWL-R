use std::{
    collections::{HashMap, HashSet},
    mem::take,
    time::{Duration, Instant},
};

use super::{Edge, SerializationDataBuffer, Triple};
use crate::{
    serializers::util::{get_reserved_iris, trim_tag_circumfix},
    vocab::owl,
};
use fluent_uri::Iri;
use futures::StreamExt;
use grapher::prelude::{
    ElementType, GraphDisplayData, OwlEdge, OwlNode, OwlType, RdfEdge, RdfType, RdfsEdge, RdfsNode,
    RdfsType,
};
use log::{debug, error, info, trace, warn};
use oxrdf::{IriParseError, NamedNode, vocab::{rdf, rdfs}};
use rdf_fusion::{
    execution::results::QuerySolutionStream,
    model::{
        Term
    },
};
use vowlr_parser::errors::VOWLRStoreError;

pub struct GraphDisplayDataSolutionSerializer {
    pub resolvable_iris: HashSet<String>,
}

impl GraphDisplayDataSolutionSerializer {
    pub fn new() -> Self {
        Self {
            resolvable_iris: get_reserved_iris(),
        }
    }

    pub async fn serialize_nodes_stream(
        &self,
        data: &mut GraphDisplayData,
        mut solution_stream: QuerySolutionStream,
    ) -> Result<(), VOWLRStoreError> {
        let mut count: u32 = 0;
        info!("Serializing query solution stream...");
        let start_time = Instant::now();
        let mut data_buffer = SerializationDataBuffer::new();
        while let Some(solution) = solution_stream.next().await {
            let solution = solution?;
            let Some(id_term) = solution.get("id") else {
                continue;
            };
            let Some(node_type_term) = solution.get("nodeType") else {
                continue;
            };

            self.extract_label(&mut data_buffer, solution.get("label"), id_term);

            let triple: Triple = Triple {
                id: id_term.to_owned(),
                element_type: node_type_term.to_owned(),
                target: solution.get("target").map(|term| term.to_owned()),
            };
            self.write_node_triple(&mut data_buffer, triple);
            count += 1;
        }
        self.check_all_unknowns(&mut data_buffer);

        let finish_time = Instant::now()
            .checked_duration_since(start_time)
            .unwrap_or(Duration::new(0, 0))
            .as_secs_f32();
        info!(
            "Serialization completed in {} s\n \
            \tTotal solutions: {count}\n \
            \tElements       : {}\n \
            \tEdges          : {}\n \
            \tLabels         : {}\n \
            \tCardinalities  : {}\n \
            \tCharacteristics: {}\n\n \
        ",
            finish_time,
            data_buffer.node_element_buffer.len(),
            data_buffer.edge_buffer.len(),
            data_buffer.label_buffer.len(),
            data_buffer.edge_characteristics.len() + data_buffer.node_characteristics.len(),
            0
        );
        if !data_buffer.failed_buffer.is_empty() {
            let total = data_buffer.failed_buffer.len();

            let mut error_log = String::from("[\n");
            for (triple, reason) in data_buffer.failed_buffer.iter() {
                match triple {
                    Some(t) => error_log.push_str(&format!("\t{} : {}\n", t, reason)),
                    None => error_log.push_str(&format!("\tNO TRIPLE : {}\n", reason)),
                }
            }
            error_log.push(']');
            error!("Failed to serialize: {}", error_log);

            return Err(VOWLRStoreError::from(format!(
                "Serialization failed ({} errors): {}",
                total, error_log
            )));
        }

        debug!("{}", data_buffer);
        *data = data_buffer.into();
        debug!("{}", data);
        Ok(())
    }

    /// Extract label info from the query solution and store until
    /// they can be mapped to their ElementType.
    fn extract_label(
        &self,
        data_buffer: &mut SerializationDataBuffer,
        label: Option<&Term>,
        id_term: &Term,
    ) {
        // Prevent overriding labels
        if data_buffer.label_buffer.contains_key(id_term) {
            return;
        }

        match label {
            // Case 1: Label is a rdfs:label OR rdfs:Resource OR rdf:ID
            Some(label) => {
                if label.to_string() != "" {
                    data_buffer
                        .label_buffer
                        .insert(id_term.clone(), label.to_string());
                } else {
                    debug!("Empty label detected for iri '{}'", id_term);
                }
            }
            // Case 2: Try parsing the iri
            None => {
                let iri = id_term.to_string();
                match Iri::parse(trim_tag_circumfix(&iri)) {
                    // Case 2.1: Look for fragments in the iri
                    Ok(id_iri) => match id_iri.fragment() {
                        Some(frag) => {
                            data_buffer
                                .label_buffer
                                .insert(id_term.clone(), frag.to_string());
                        }
                        // Case 2.2: Look for path in iri
                        None => {
                            debug!("No fragment found in iri '{iri}'");
                            match id_iri.path().rsplit_once('/') {
                                Some(path) => {
                                    data_buffer
                                        .label_buffer
                                        .insert(id_term.clone(), path.1.to_string());
                                }
                                None => {
                                    debug!("No path found in iri '{iri}'");
                                }
                            }
                        }
                    },
                    Err(e) => {
                        // Do not make a 'warn!'. A parse error is allowed to happen (e.g. on blank nodes).
                        trace!("Failed to parse iri '{}':\n{:?}", iri, e);
                    }
                }
            }
        };
    }

    fn resolve(&self, data_buffer: &SerializationDataBuffer, mut x: Term) -> Option<Term> {
        if let Some(elem) = data_buffer.node_element_buffer.get(&x) {
            debug!("Resolved: {}: {}", x, elem);
            return Some(x);
        } else if let Some(elem) = data_buffer.edge_element_buffer.get(&x) {
            debug!("Resolved: {}: {}", x, elem);
            return Some(x);
        }

        while let Some(redirected) = data_buffer.edge_redirection.get(&x) {
            trace!("Redirected: {} -> {}", x, redirected);
            let new_x = redirected.clone();
            if let Some(elem) = data_buffer.node_element_buffer.get(&new_x) {
                debug!("Resolved: {}: {}", new_x, elem);
                return Some(new_x);
            } else if let Some(elem) = data_buffer.edge_element_buffer.get(&new_x) {
                debug!("Resolved: {}: {}", new_x, elem);
                return Some(new_x);
            }
            debug!("Checked: {} ", new_x);
            x = new_x;
        }
        None
    }
    fn resolve_so(
        &self,
        data_buffer: &SerializationDataBuffer,
        triple: &Triple,
    ) -> (Option<Term>, Option<Term>) {
        let resolved_subject = self.resolve(data_buffer, triple.id.clone());
        let resolved_object = match &triple.target {
            Some(target) => self.resolve(data_buffer, target.clone()),
            None => {
                warn!("No object in triple:\n {}", triple);
                None
            }
        };
        (resolved_subject, resolved_object)
    }

    /// Add subject of triple to the element buffer.
    ///
    /// In the future, this function will handle cases where an element
    /// identifies itself as multiple elements. E.g. an element is both an rdfs:Class and a owl:class.
    fn add_to_element_buffer(
        &self,
        element_buffer: &mut HashMap<Term, ElementType>,
        triple: &Triple,
        element_type: ElementType,
    ) {
        if let Some(element) = element_buffer.get(&triple.id) {
            warn!(
                "Attempted to register '{}' to subject '{}' already registered as '{}'. Skipping",
                element_type, triple.id, element
            );
        } else {
            trace!("Adding to element buffer: {}: {}", triple.id, element_type);
            element_buffer.insert(triple.id.clone(), element_type);
        }
    }

    /// Add an IRI to the unresolved, unknown buffer.
    fn add_to_unknown_buffer(
        &self,
        data_buffer: &mut SerializationDataBuffer,
        element_iri: Term,
        triple: Triple,
    ) {
        trace!("Adding to unknown buffer: {}: {}", element_iri, triple);
        if let Some(id_unknowns) = data_buffer.unknown_buffer.get_mut(&element_iri) {
            id_unknowns.insert(triple);
        } else {
            let mut id_unknowns = HashSet::new();
            id_unknowns.insert(triple);
            data_buffer.unknown_buffer.insert(element_iri, id_unknowns);
        }
    }

    /// Insert an edge into the element's edge set.
    fn insert_edge_include(
        &self,
        data_buffer: &mut SerializationDataBuffer,
        element_iri: &Term,
        edge: Edge,
    ) {
        data_buffer
            .edges_include_map
            .entry(element_iri.clone())
            .or_default()
            .insert(edge);
    }

    pub fn redirect_iri(&self, data_buffer: &mut SerializationDataBuffer, old: &Term, new: &Term) {
        debug!("Redirecting '{}' to '{}'", old, new);
        data_buffer
            .edge_redirection
            .insert(old.clone(), new.clone());
        self.check_unknown_buffer(data_buffer, old);
    }

    pub fn check_unknown_buffer(&self, data_buffer: &mut SerializationDataBuffer, term: &Term) {
        let triple = data_buffer.unknown_buffer.remove(term);
        if let Some(triples) = triple {
            for triple in triples {
                self.write_node_triple(data_buffer, triple);
            }
        }
    }

    fn insert_node(
        &self,
        data_buffer: &mut SerializationDataBuffer,
        triple: &Triple,
        node_type: ElementType,
    ) {
        // Skip insertion if this node was already merged into another node
        if data_buffer.edge_redirection.contains_key(&triple.id) {
            debug!(
                "Skipping insert_node for '{}': already redirected",
                triple.id
            );
            return;
        }

        self.add_to_element_buffer(&mut data_buffer.node_element_buffer, triple, node_type);
        self.check_unknown_buffer(data_buffer, &triple.id);
    }

    /// Inserts an edge triple into the serialization buffer,
    /// where subject and object are both nodes.
    ///
    /// Note that tuples or any triple where the subject is an edge iri,
    /// not present in the element buffer, will NEVER be resolved!
    fn insert_edge(
        &self,
        data_buffer: &mut SerializationDataBuffer,
        triple: &Triple,
        edge_type: ElementType,
        label: Option<String>,
    ) -> Option<Edge> {
        // Skip external check for NoDraw edges - they should always retain their type
        let new_type =
            if edge_type != ElementType::NoDraw && self.is_external(data_buffer, &triple.id) {
                ElementType::Owl(OwlType::Edge(OwlEdge::ExternalProperty))
            } else {
                edge_type
            };
        match self.resolve_so(data_buffer, triple) {
            (Some(sub_iri), Some(obj_iri)) => {
                let should_hash_property = [
                    ElementType::Owl(OwlType::Edge(OwlEdge::ObjectProperty)),
                    ElementType::Owl(OwlType::Edge(OwlEdge::DatatypeProperty)),
                    ElementType::Owl(OwlType::Edge(OwlEdge::DeprecatedProperty)),
                    ElementType::Owl(OwlType::Edge(OwlEdge::ExternalProperty)),
                ];
                let property = if should_hash_property.contains(&new_type) {
                    Some(triple.element_type.clone())
                } else {
                    None
                };
                let edge = Edge {
                    subject: sub_iri.clone(),
                    element_type: new_type,
                    object: obj_iri.clone(),
                    property,
                };
                trace!(
                    "Inserting edge: {} -> {} -> {}",
                    edge.subject, edge.element_type, edge.object
                );
                data_buffer.edge_buffer.insert(edge.clone());
                self.insert_edge_include(data_buffer, &sub_iri, edge.clone());
                self.insert_edge_include(data_buffer, &obj_iri, edge.clone());

                data_buffer
                    .edge_label_buffer
                    .insert(edge.clone(), label.unwrap_or(new_type.to_string()));
                return Some(edge);
            }
            (None, Some(_)) => {
                warn!("Cannot resolve subject of triple:\n {}", triple);
                self.add_to_unknown_buffer(data_buffer, triple.id.clone(), triple.clone());
            }
            (Some(_), None) => {
                if let Some(obj_iri) = &triple.target {
                    warn!("Cannot resolve object of triple:\n {}", triple);
                    // resolve_so already warns about unresolved object. No need to repeat it here.
                    self.add_to_unknown_buffer(data_buffer, obj_iri.clone(), triple.clone());
                }
            }
            _ => {
                warn!("Cannot resolve subject and object of triple:\n {}", triple);
                self.add_to_unknown_buffer(data_buffer, triple.id.clone(), triple.clone());
            }
        }
        None
    }

    fn is_external(&self, data_buffer: &SerializationDataBuffer, iri: &Term) -> bool {
        if iri.is_blank_node() {
            return false;
        }
        let clean_iri = trim_tag_circumfix(&iri.to_string());
        match &data_buffer.document_base {
            Some(base) => !clean_iri.contains(base) && !self.resolvable_iris.contains(&clean_iri),
            None => {
                warn!("Cannot determine externals: Missing document base!");
                false
            }
        }
    }

    fn merge_nodes(&self, data_buffer: &mut SerializationDataBuffer, old: &Term, new: &Term) {
        debug!("Merging node '{old}' into '{new}'");
        data_buffer.node_element_buffer.remove(old);
        self.update_edges(data_buffer, old, new);
        self.redirect_iri(data_buffer, old, new);
    }

    fn update_edges(&self, data_buffer: &mut SerializationDataBuffer, old: &Term, new: &Term) {
        let old_edges = data_buffer.edges_include_map.remove(old);
        if let Some(old_edges) = old_edges {
            debug!("Updating edges from '{}' to '{}'", old, new);
            // info!("old_edges: ");
            // for edge in old_edges.iter() {
            //     info!("edge: {} ", edge);
            // }

            for mut edge in old_edges.into_iter() {
                data_buffer.edge_buffer.remove(&edge);
                if edge.object == *old {
                    edge.object = new.clone();
                }
                if edge.subject == *old {
                    edge.subject = new.clone();
                }
                data_buffer.edge_buffer.insert(edge.clone());
                self.insert_edge_include(data_buffer, new, edge.clone());
            }
            // info!("new_edges: ");
            // for edge in data_buffer.edge_buffer.iter() {
            //     info!("edge: {} ", edge);
            // }
        }
    }

    fn upgrade_node_type(
        &self,
        data_buffer: &mut SerializationDataBuffer,
        iri: &Term,
        new_element: ElementType,
    ) {
        let old_elem_opt = data_buffer.node_element_buffer.get(iri).cloned();
        match old_elem_opt {
            Some(old_elem) => {
                if old_elem == ElementType::Owl(OwlType::Node(OwlNode::Class)) {
                    data_buffer
                        .node_element_buffer
                        .insert(iri.clone(), new_element);
                }
                debug!(
                    "Upgraded subject '{}' from {} to {}",
                    iri, old_elem, new_element
                )
            }
            None => {
                warn!("Upgraded unresolved subject '{}' to {}", iri, new_element)
            }
        }
    }

    /// Appends a string to an element's label.
    fn extend_element_label(
        &self,
        data_buffer: &mut SerializationDataBuffer,
        element: &Term,
        label_to_append: String,
    ) {
        debug!(
            "Extending element '{}' with label '{}'",
            element, label_to_append
        );
        if let Some(label) = data_buffer.label_buffer.get_mut(element) {
            label.push_str(format!("\n{}", label_to_append).as_str());
        } else {
            data_buffer
                .label_buffer
                .insert(element.clone(), label_to_append.clone());
        }
    }

    fn create_node(
        &self,
        id: String,
        node_type: NamedNode,
        object_iri: Option<String>,
    ) -> Result<Triple, IriParseError> {
        let subject = NamedNode::new(id)?;
        let object = match object_iri {
            Some(iri) => {
                let obj = NamedNode::new(iri)?;
                Some(Term::NamedNode(obj))
            }
            None => None,
        };

        let t = Triple::new(Term::NamedNode(subject), Term::NamedNode(node_type), object);
        debug!("Created new triple: {}", t);
        Ok(t)
    }

    fn check_all_unknowns(&self, data_buffer: &mut SerializationDataBuffer) {
        info!("Third pass: Resolving all possible unknowns");

        let unknowns = take(&mut data_buffer.unknown_buffer);
        for (_, triples) in unknowns {
            for triple in triples {
                self.write_node_triple(data_buffer, triple);
            }
        }
    }

    /// Serialize a triple to `data_buffer`.
    fn write_node_triple(&self, data_buffer: &mut SerializationDataBuffer, triple: Triple) {
        // TODO: Collect errors and show to frontend
        debug!("{}", triple);
        match &triple.element_type {
            Term::BlankNode(bnode) => {
                // The query must never put blank nodes in the ?nodeType variable
                let msg = format!("Illegal blank node during serialization: '{bnode}'");
                data_buffer.failed_buffer.push((Some(triple), msg));
            }
            Term::Literal(literal) => {
                // NOTE: Any string literal goes here, e.g. 'EquivalentClass'.
                // That is, every BIND("someString" AS ?nodeType)
                let value = literal.value();
                match value {
                    "blanknode" => {
                        info!("Visualizing blank node: {}", triple.id);
                        self.insert_node(
                            data_buffer,
                            &triple,
                            ElementType::Owl(OwlType::Node(OwlNode::AnonymousClass)),
                        );
                    }
                    &_ => {
                        warn!("Visualization of literal '{value}' is not supported");
                    }
                }
            }
            Term::NamedNode(uri) => {
                // NOTE: Only supports RDF 1.1
                match uri.as_ref() {
                    // ----------- RDF ----------- //

                    // rdf::ALT => {}
                    // rdf::BAG => {}
                    // rdf::FIRST => {}
                    // rdf::HTML => {}
                    // rdf::LANG_STRING => {}
                    // rdf::LIST => {}
                    // rdf::NIL => {}
                    // rdf::OBJECT => {}
                    // rdf::PREDICATE => {}
                    rdf::PROPERTY => {
                        self.insert_edge(
                            data_buffer,
                            &triple,
                            ElementType::Rdf(RdfType::Edge(RdfEdge::RdfProperty)),
                            None,
                        );
                    }
                    // rdf::REST => {}
                    // rdf::SEQ => {}
                    // rdf::STATEMENT => {}
                    // rdf::SUBJECT => {}
                    // rdf::TYPE => {}
                    // rdf::VALUE => {}
                    // rdf::XML_LITERAL => {}

                    // ----------- RDFS ----------- //
                    rdfs::CLASS => self.insert_node(
                        data_buffer,
                        &triple,
                        ElementType::Rdfs(RdfsType::Node(RdfsNode::Class)),
                    ),

                    //TODO: OWL1
                    // rdfs::COMMENT => {}

                    // rdfs::CONTAINER => {}
                    // rdfs::CONTAINER_MEMBERSHIP_PROPERTY => {}
                    rdfs::DATATYPE => {
                        self.insert_node(
                            data_buffer,
                            &triple,
                            ElementType::Rdfs(RdfsType::Node(RdfsNode::Datatype)),
                        );
                    }
                    rdfs::DOMAIN => {
                        error!(
                            "sparql query should not have rdfs:domain triples: {}",
                            triple
                        );
                    }

                    // rdfs::IS_DEFINED_BY => {}

                    // rdfs::LABEL => {}
                    rdfs::LITERAL => {
                        self.insert_node(
                            data_buffer,
                            &triple,
                            ElementType::Rdfs(RdfsType::Node(RdfsNode::Literal)),
                        );
                    }
                    // rdfs::MEMBER => {}
                    rdfs::RANGE => {
                        error!(
                            "sparql query should not have rdfs:range triples: {}",
                            triple
                        );
                    }
                    rdfs::RESOURCE => {
                        self.insert_node(
                            data_buffer,
                            &triple,
                            ElementType::Rdfs(RdfsType::Node(RdfsNode::Resource)),
                        );
                    }

                    //TODO: OWL1
                    // rdfs::SEE_ALSO => {}
                    rdfs::SUB_CLASS_OF => {
                        self.insert_edge(
                            data_buffer,
                            &triple,
                            ElementType::Rdfs(RdfsType::Edge(RdfsEdge::SubclassOf)),
                            None,
                        );
                    }
                    //TODO: OWL1
                    //rdfs::SUB_PROPERTY_OF => {},

                    // ----------- OWL 2 ----------- //

                    //TODO: OWL1
                    // owl::ALL_DIFFERENT => {},

                    // owl::ALL_DISJOINT_CLASSES => {},
                    // owl::ALL_DISJOINT_PROPERTIES => {},

                    //TODO: OWL1
                    // owl::ALL_VALUES_FROM => {}

                    // owl::ANNOTATED_PROPERTY => {},
                    // owl::ANNOTATED_SOURCE => {},
                    // owl::ANNOTATED_TARGET => {},
                    // owl::ANNOTATION => {},

                    //TODO: OWL1
                    // owl::ANNOTATION_PROPERTY => {},

                    // owl::ASSERTION_PROPERTY => {},

                    //TODO: OWL1
                    // owl::ASYMMETRIC_PROPERTY => {},

                    // owl::AXIOM => {},
                    // owl::BACKWARD_COMPATIBLE_WITH => {},
                    // owl::BOTTOM_DATA_PROPERTY => {},
                    // owl::BOTTOM_OBJECT_PROPERTY => {},

                    //TODO: OWL1
                    // owl::CARDINALITY => {}
                    owl::CLASS => self.insert_node(
                        data_buffer,
                        &triple,
                        ElementType::Owl(OwlType::Node(OwlNode::Class)),
                    ),
                    owl::COMPLEMENT_OF => {
                        self.insert_edge(data_buffer, &triple, ElementType::NoDraw, None);
                        if triple.target.is_some()
                            && let Some(index) = self.resolve(data_buffer, triple.id.clone())
                        {
                            self.upgrade_node_type(
                                data_buffer,
                                &index,
                                ElementType::Owl(OwlType::Node(OwlNode::Complement)),
                            );
                        }
                    }

                    //TODO: OWL1
                    //owl::DATATYPE_COMPLEMENT_OF => {}
                    owl::DATATYPE_PROPERTY => {
                        let e = ElementType::Owl(OwlType::Edge(OwlEdge::DatatypeProperty));
                        self.add_to_element_buffer(
                            &mut data_buffer.edge_element_buffer,
                            &triple,
                            e,
                        );
                    }

                    //TODO: OWL1 (deprecated in OWL2, replaced by rdfs:datatype)
                    // owl::DATA_RANGE => {}

                    // owl::DEPRECATED => {}
                    owl::DEPRECATED_CLASS => self.insert_node(
                        data_buffer,
                        &triple,
                        ElementType::Owl(OwlType::Node(OwlNode::DeprecatedClass)),
                    ),
                    owl::DEPRECATED_PROPERTY => {
                        self.insert_edge(
                            data_buffer,
                            &triple,
                            ElementType::Owl(OwlType::Edge(OwlEdge::DeprecatedProperty)),
                            None,
                        );
                    }

                    //TODO: OWL1
                    // owl::DIFFERENT_FROM => {}
                    owl::DISJOINT_UNION_OF => {
                        self.insert_edge(data_buffer, &triple, ElementType::NoDraw, None);
                        if triple.target.is_some()
                            && let Some(index) = self.resolve(data_buffer, triple.id.clone())
                        {
                            self.upgrade_node_type(
                                data_buffer,
                                &index,
                                ElementType::Owl(OwlType::Node(OwlNode::DisjointUnion)),
                            );
                        }
                    }
                    owl::DISJOINT_WITH => {
                        self.insert_edge(
                            data_buffer,
                            &triple,
                            ElementType::Owl(OwlType::Edge(OwlEdge::DisjointWith)),
                            None,
                        );
                    }

                    //TODO: OWL1
                    // owl::DISTINCT_MEMBERS => {}
                    owl::EQUIVALENT_CLASS => {
                        match &triple.target {
                            Some(target) => {
                                if target.is_named_node() {
                                    // Case 1:
                                    // The subject of an equivalentClass relation should
                                    // become a full-fledged equivalent class. This happens
                                    // if the subject and object of the equivalentClass relation
                                    // are both named classes (i.e. not blank nodes).
                                    //
                                    // In other words, the object must be removed from existence,
                                    // and have all references to it (incl. labels) point to
                                    // the subject.

                                    // Move object label to subject.
                                    if let Some(label) = data_buffer.label_buffer.remove(target) {
                                        debug!("Removed label: {}", label);
                                        self.extend_element_label(data_buffer, &triple.id, label);
                                    }

                                    // Remove object from existence.
                                    match data_buffer.node_element_buffer.remove(target) {
                                        // Case 1.1: Object exists in the elememt buffer
                                        Some(_) => {
                                            self.merge_nodes(data_buffer, target, &triple.id);
                                        }
                                        // Case 1.2: Look in the unknown buffer
                                        None => match data_buffer.unknown_buffer.remove(target) {
                                            Some(items) => {
                                                if !items.is_empty() {
                                                    warn!(
                                                        "Removed unresolved triples for object '{}' during merge into equivalent subject '{}':\n\t{:#?}",
                                                        target, triple.id, items
                                                    );
                                                }
                                            }
                                            None => {
                                                data_buffer.failed_buffer.push((Some(triple), "Failed to merge object of equivalence relation into subject: object not found".to_string()));
                                                return;
                                            }
                                        },
                                    }
                                    self.upgrade_node_type(
                                        data_buffer,
                                        &triple.id,
                                        ElementType::Owl(OwlType::Node(OwlNode::EquivalentClass)),
                                    );
                                } else if target.is_blank_node() {
                                    // Case 2:
                                    // The subject of an equivalentClass relation should
                                    // could either be start of a collection or anon class
                                    let (index_s, index_o) = self.resolve_so(data_buffer, &triple);
                                    match (index_s, index_o) {
                                        (Some(index_s), Some(index_o)) => {
                                            self.merge_nodes(data_buffer, &index_o, &index_s);
                                        }
                                        (Some(index_s), None) => {
                                            if let Some(target) = &triple.target {
                                                self.redirect_iri(data_buffer, target, &index_s);
                                            } else {
                                                data_buffer.failed_buffer.push((
                                                    Some(triple),
                                                    "Failed to redirect object: not found"
                                                        .to_string(),
                                                ));
                                            }
                                        }
                                        _ => {
                                            self.add_to_unknown_buffer(
                                                data_buffer,
                                                target.clone(),
                                                triple,
                                            );
                                        }
                                    }
                                } else {
                                    data_buffer.failed_buffer.push((Some(triple), "Visualization of equivalence relations between classes and literals is not supported".to_string()));
                                }
                            }
                            None => {
                                data_buffer.failed_buffer.push((
                                    Some(triple),
                                    "Subject of equivalence relation is missing an object"
                                        .to_string(),
                                ));
                            }
                        }
                    }
                    // owl::EQUIVALENT_PROPERTY => {}

                    //TODO: OWL1
                    //owl::FUNCTIONAL_PROPERTY => {}

                    // owl::HAS_KEY => {}
                    // owl::HAS_SELF => {}

                    //TODO: OWL1
                    // owl::HAS_VALUE => {}

                    // owl::IMPORTS => {}
                    // owl::INCOMPATIBLE_WITH => {}
                    owl::INTERSECTION_OF => {
                        let edge =
                            self.insert_edge(data_buffer, &triple, ElementType::NoDraw, None);
                        if let Some(edge) = edge {
                            self.upgrade_node_type(
                                data_buffer,
                                &edge.subject,
                                ElementType::Owl(OwlType::Node(OwlNode::IntersectionOf)),
                            );
                        }
                    }
                    owl::INVERSE_FUNCTIONAL_PROPERTY => {
                        self.insert_characteristic(
                            data_buffer,
                            triple,
                            "InverseFunctionalProperty".to_string(),
                        );
                    }
                    // TODO owl::INVERSE_OF => {}
                    // owl::IRREFLEXIVE_PROPERTY => {}

                    //TODO: OWL1
                    // owl::MAX_CARDINALITY => {}

                    // owl::MAX_QUALIFIED_CARDINALITY => {}
                    // owl::MEMBERS => {}

                    //TODO: OWL1
                    // owl::MIN_CARDINALITY => {}
                    // owl::MIN_QUALIFIED_CARDINALITY => {}
                    // owl::NAMED_INDIVIDUAL => {}
                    // owl::NEGATIVE_PROPERTY_ASSERTION => {}

                    //TODO: OWL1
                    //owl::NOTHING => {}
                    owl::OBJECT_PROPERTY => {
                        let e = ElementType::Owl(OwlType::Edge(OwlEdge::ObjectProperty));
                        self.add_to_element_buffer(
                            &mut data_buffer.edge_element_buffer,
                            &triple,
                            e,
                        );
                    }
                    // owl::ONE_OF => {}
                    owl::ONTOLOGY => {
                        if let Some(base) = &data_buffer.document_base {
                            warn!(
                                "Attempting to override document base '{base}' with new base '{}'. Skipping",
                                triple.id
                            );
                        } else {
                            let base = trim_tag_circumfix(&triple.id.to_string());
                            info!("Using document base: '{}'", base);
                            data_buffer.document_base = Some(base);
                        }
                    }

                    //TODO: OWL1
                    // owl::ONTOLOGY_PROPERTY => {}

                    // owl::ON_CLASS => {}
                    // owl::ON_DATARANGE => {}
                    // owl::ON_DATATYPE => {}
                    // owl::ON_PROPERTIES => {}

                    //TODO: OWL1
                    // owl::ON_PROPERTY => {}

                    // owl::PRIOR_VERSION => {}
                    // owl::PROPERTY_CHAIN_AXIOM => {}
                    // owl::PROPERTY_DISJOINT_WITH => {}
                    // owl::QUALIFIED_CARDINALITY => {}

                    //TODO: OWL1
                    // owl::REFLEXIVE_PROPERTY => {}

                    //TODO: OWL1
                    // owl::RESTRICTION => {}

                    //TODO: OWL1
                    // owl::SAME_AS => {}

                    //TODO: OWL1
                    // owl::SOME_VALUES_FROM => {}
                    // owl::SOURCE_INDIVIDUAL => {}
                    // owl::SYMMETRIC_PROPERTY => {}
                    // owl::TARGET_INDIVIDUAL => {}
                    // owl::TARGET_VALUE => {}
                    owl::THING => self.insert_node(
                        data_buffer,
                        &triple,
                        ElementType::Owl(OwlType::Node(OwlNode::Thing)),
                    ),
                    // owl::TOP_DATA_PROPERTY => {}
                    // owl::TOP_OBJECT_PROPERTY => {}

                    //TODO: OWL1
                    //owl::TRANSITIVE_PROPERTY => {}
                    owl::UNION_OF => {
                        let edge =
                            self.insert_edge(data_buffer, &triple, ElementType::NoDraw, None);
                        if let Some(edge) = edge {
                            self.upgrade_node_type(
                                data_buffer,
                                &edge.subject,
                                ElementType::Owl(OwlType::Node(OwlNode::UnionOf)),
                            );
                        }
                    }
                    // owl::VERSION_INFO => {}
                    // owl::VERSION_IRI => {}
                    // owl::WITH_RESTRICTIONS => {}
                    _ => match triple.target.clone() {
                        Some(target) => {
                            let (node_triple, edge_triple): (Option<Vec<Triple>>, Option<Triple>) =
                                match (
                                    self.resolve(data_buffer, triple.id.clone()),
                                    self.resolve(data_buffer, triple.element_type.clone()),
                                    self.resolve(data_buffer, target.clone()),
                                ) {
                                    (Some(domain), Some(property), Some(range)) => {
                                        trace!(
                                            "Resolving object property: range: {}, property: {}, domain: {}",
                                            range, property, domain
                                        );
                                        (None, Some(triple))
                                    }
                                    (Some(domain), Some(property), None) => {
                                        let node = if target == owl::THING.into() {
                                            let target_iri = trim_tag_circumfix(format!("{}_thing", domain).as_str());
                                            let node = self.create_node(
                                                target_iri.clone(),
                                                owl::THING.into(),
                                                None,
                                            );
                                            node.ok()
                                        } else if target == rdfs::LITERAL.into() {
                                            let target_iri = trim_tag_circumfix(format!("{}_literal", property).as_str());
                                            let node = self.create_node(
                                                target_iri.clone(),
                                                rdfs::LITERAL.into(),
                                                None,
                                            );
                                            node.ok()
                                        } else {
                                            None
                                        };
                                        match node {
                                            Some(node) => (
                                                Some(vec![node.clone()]),
                                                Some(Triple {
                                                    id: triple.id,
                                                    element_type: triple.element_type,
                                                    target: Some(node.id),
                                                }),
                                            ),
                                            None => {
                                                trace!(
                                                    "Adding unknown buffer: target: {}, triple: {}",
                                                    target, triple
                                                );
                                                self.add_to_unknown_buffer(
                                                    data_buffer,
                                                    target,
                                                    triple,
                                                );
                                                (None, None)
                                            }
                                        }
                                    }
                                    (None, Some(_), Some(range)) => {
                                        let node = if target == owl::THING.into() {
                                            let target_iri = trim_tag_circumfix(format!("{}_thing", range).as_str());
                                            let node = self.create_node(
                                                target_iri.clone(),
                                                owl::THING.into(),
                                                None,
                                            );
                                            node.ok()
                                        } else if target == rdfs::LITERAL.into() {
                                            let target_iri = trim_tag_circumfix(format!("{}_literal", range).as_str());
                                            let node = self.create_node(
                                                target_iri.clone(),
                                                rdfs::LITERAL.into(),
                                                None,
                                            );
                                            node.ok()
                                        } else {
                                            None
                                        };
                                        match node {
                                            Some(node) => (
                                                Some(vec![node.clone()]),
                                                Some(Triple {
                                                    id: node.id,
                                                    element_type: triple.element_type,
                                                    target: node.target,
                                                }),
                                            ),
                                            None => {
                                                trace!(
                                                    "Adding unknown buffer: target: {}, triple: {}",
                                                    target, triple
                                                );
                                                self.add_to_unknown_buffer(
                                                    data_buffer,
                                                    target,
                                                    triple,
                                                );
                                                (None, None)
                                            }
                                        }
                                    }
                                    (None, Some(property), None) => {
                                        trace!("No domain and range: {}", triple);
                                        if triple.element_type == owl::DATATYPE_PROPERTY.into() {
                                            let local_literal = NamedNode::new( property.to_string() + "_locallitral").unwrap();
                                            let literal_triple = self.create_node(
                                                local_literal.to_string(),
                                                rdfs::LITERAL.into(),
                                                None,
                                            );
                                            let local_thing = NamedNode::new( property.to_string() + "_localthing").unwrap();
                                            let thing_triple = self.create_node(
                                                local_thing.to_string(),
                                                owl::THING.into(),
                                                None,
                                            );
                                            match (literal_triple, thing_triple) {
                                                (Ok(literal), Ok(thing)) => {
                                                    (
                                                        Some(vec![literal.clone(), thing.clone()]),
                                                        Some(Triple {
                                                            id: thing.id.clone(),
                                                            element_type: triple.element_type,
                                                            target: Some(literal.id)
                                                        }),
                                                    )
                                                }
                                                (_, _) => (None, None)
                                            }
                                        } else if triple.element_type == owl::OBJECT_PROPERTY.into() {
                                            let global_thing =
                                                NamedNode::new(owl::THING.to_string() + "_thing")
                                                    .unwrap();
                                            let node_triple = self.create_node(
                                                global_thing.to_string(),
                                                global_thing,
                                                None,
                                            );
                                            match node_triple {
                                                Ok(node) => (
                                                    Some(vec![node.clone()]),
                                                    Some(Triple {
                                                        id: node.id.clone(),
                                                        element_type: triple.element_type,
                                                        target: Some(node.id),
                                                    }),
                                                ),
                                                Err(e) => {
                                                    error!("Error creating node: {}", e);
                                                    (None, None)
                                                }
                                            }
                                        } else { (None, None) }
                                    }

                                    (Some(_), None, Some(_)) => {
                                        trace!(
                                            "Adding unknown buffer: element type: {}, triple: {}",
                                            triple.element_type, triple
                                        );
                                        self.add_to_unknown_buffer(
                                            data_buffer,
                                            triple.element_type.clone(),
                                            triple,
                                        );
                                        (None, None)
                                    }
                                    _ => {
                                        trace!("Adding unknown buffer: triple: {}", triple);
                                        self.add_to_unknown_buffer(
                                            data_buffer,
                                            triple.id.clone(),
                                            triple,
                                        );
                                        (None, None)
                                    }
                            };
                            match node_triple {
                                Some(node_triples) => {
                                    for node_triple in node_triples {
                                        if node_triple.element_type == owl::THING.into() {
                                            self.insert_node(
                                                data_buffer,
                                                &node_triple,
                                                ElementType::Owl(OwlType::Node(OwlNode::Thing)),
                                            );
                                        } else if node_triple.element_type == rdfs::LITERAL.into() {
                                            self.insert_node(
                                                data_buffer,    
                                                &node_triple,
                                                ElementType::Rdfs(RdfsType::Node(RdfsNode::Literal)),
                                            );
                                        }
                                    }
                                }
                                None => error!("Error creating node {:?}", node_triple),
                            }
                            
                            match edge_triple {
                                Some(edge_triple) => {
                                    let edge = self.insert_edge(
                                        data_buffer,
                                        &edge_triple,
                                        ElementType::Owl(OwlType::Edge(OwlEdge::ObjectProperty)),
                                        data_buffer
                                            .label_buffer
                                            .get(&edge_triple.element_type)
                                            .cloned(),
                                    );
                                    if let Some(edge) = edge {
                                        data_buffer.add_property_edge(
                                            edge_triple.element_type.to_string(),
                                            edge,
                                        );
                                        data_buffer.add_property_domain(
                                            edge_triple.element_type.to_string(),
                                            edge_triple
                                                .target
                                                .clone()
                                                .expect("target should be a string")
                                                .to_string(),
                                        );
                                        data_buffer.add_property_range(
                                            edge_triple.element_type.to_string(),
                                            edge_triple.id.to_string(),
                                        );
                                    }
                                }
                                None => {
                                    error!("Error creating edge: ");
                                }
                            }
                        }
                        None => {
                            error!("object property triples should have a target: {}", triple);
                        }
                    },
                };
            }
        }
    }

    fn insert_characteristic(
        &self,
        data_buffer: &mut SerializationDataBuffer,
        triple: Triple,
        arg: String,
    ) {
        let resolved = self.resolve(data_buffer, triple.id.clone());
        match resolved {
            Some(s) => match data_buffer.node_characteristics.get_mut(&s) {
                Some(char) => {
                    for (k, v) in data_buffer.property_edge_map.iter() {
                        info!("{} -> {}", k, v);
                    }
                    info!("Inserting characteristic: {} -> {}", s, arg);
                    char.push(arg);
                }
                None => {
                    for (k, v) in data_buffer.property_edge_map.iter() {
                        info!("{} -> {}", k, v);
                    }
                    info!("Inserting characteristic: {} -> {}", s, arg);
                    //data_buffer.edge_characteristics.insert(s, vec![arg]);
                }
            },
            None => {
                info!("Adding characteristic to unknown buffer: {}", triple);
                self.add_to_unknown_buffer(data_buffer, triple.id.clone(), triple);
            }
        }
    }
}

impl Default for GraphDisplayDataSolutionSerializer {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
#[allow(unused_must_use)]
mod test {
    use super::*;
    use oxrdf::{BlankNode, Literal, NamedNode};

    #[test]
    fn test_replace_node() {
        let _ = env_logger::builder().is_test(true).try_init();
        let serializer = GraphDisplayDataSolutionSerializer::new();
        let mut data_buffer = SerializationDataBuffer::new();

        let example_com = Term::NamedNode(NamedNode::new("http://example.com#").unwrap());
        let owl_ontology =
            Term::NamedNode(NamedNode::new("http://www.w3.org/2002/07/owl#Ontology").unwrap());
        let example_parent = Term::NamedNode(NamedNode::new("http://example.com#Parent").unwrap());
        let owl_class =
            Term::NamedNode(NamedNode::new("http://www.w3.org/2002/07/owl#Class").unwrap());
        let example_mother = Term::NamedNode(NamedNode::new("http://example.com#Mother").unwrap());
        let example_guardian =
            Term::NamedNode(NamedNode::new("http://example.com#Guardian").unwrap());
        let example_warden = Term::NamedNode(NamedNode::new("http://example.com#Warden").unwrap());
        let example_warden1 =
            Term::NamedNode(NamedNode::new("http://example.com#Warden1").unwrap());
        let rdfs_subclass_of = Term::NamedNode(
            NamedNode::new("http://www.w3.org/2000/01/rdf-schema#subClassOf").unwrap(),
        );
        let blanknode1 =
            Term::BlankNode(BlankNode::new("e1013e66f734c508511575854b0c9396").unwrap());

        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: example_com.clone(),
                element_type: owl_ontology.clone(),
                target: None,
            },
        );
        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: example_parent.clone(),
                element_type: owl_class.clone(),
                target: None,
            },
        );
        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: example_mother.clone(),
                element_type: owl_class.clone(),
                target: None,
            },
        );
        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: example_guardian.clone(),
                element_type: owl_class.clone(),
                target: None,
            },
        );
        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: example_warden.clone(),
                element_type: owl_class.clone(),
                target: None,
            },
        );
        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: example_warden1.clone(),
                element_type: owl_class.clone(),
                target: None,
            },
        );
        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: example_warden.clone(),
                element_type: rdfs_subclass_of.clone(),
                target: Some(example_guardian.clone()),
            },
        );
        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: example_mother.clone(),
                element_type: rdfs_subclass_of.clone(),
                target: Some(example_parent.clone()),
            },
        );
        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: blanknode1.clone(),
                element_type: Term::Literal(Literal::new_simple_literal("blanknode".to_string())),
                target: None,
            },
        );
        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: example_warden1.clone(),
                element_type: Term::NamedNode(
                    NamedNode::new("http://www.w3.org/2002/07/owl#unionOf").unwrap(),
                ),
                target: Some(example_warden.clone()),
            },
        );

        print_graph_display_data(&data_buffer);
        println!("--------------------------------");

        let triple = Triple {
            id: example_guardian.clone(),
            element_type: Term::NamedNode(
                NamedNode::new("http://www.w3.org/2002/07/owl#equivalentClass").unwrap(),
            ),
            target: Some(example_warden.clone()),
        };
        serializer.write_node_triple(&mut data_buffer, triple);
        for (k, v) in data_buffer.node_element_buffer.iter() {
            println!("element_buffer: {} -> {}", k, v);
        }
        for (k, v) in data_buffer.edges_include_map.iter() {
            println!("edges_include_map: {} -> {:?}", k, v);
        }
        for (k, v) in data_buffer.edge_redirection.iter() {
            println!("edge_redirection: {} -> {}", k, v);
        }
        assert!(
            data_buffer
                .node_element_buffer
                .contains_key(&example_guardian.clone())
        );
        assert!(
            !data_buffer
                .node_element_buffer
                .contains_key(&example_warden)
        );
        assert!(
            data_buffer
                .node_element_buffer
                .contains_key(&example_warden1)
        );
        assert!(data_buffer.edges_include_map.contains_key(&example_warden1));

        assert!(data_buffer.edge_buffer.contains(&Edge {
            subject: example_warden1,
            element_type: ElementType::NoDraw,
            object: example_guardian.clone(),
            property: None
        }));
        assert!(data_buffer.edge_redirection.contains_key(&example_warden));
        assert_eq!(
            data_buffer
                .edge_redirection
                .get(&example_warden)
                .unwrap()
                .clone(),
            example_guardian
        );
        serializer.write_node_triple(
            &mut data_buffer,
            Triple {
                id: Term::NamedNode(NamedNode::new("http://example.com#Guardian").unwrap()),
                element_type: Term::NamedNode(
                    NamedNode::new("http://www.w3.org/2002/07/owl#equivalentClass").unwrap(),
                ),
                target: Some(blanknode1.clone()),
            },
        );
        let s = serializer.resolve(&data_buffer, blanknode1.clone());
        assert!(s.is_some());
        for (k, v) in data_buffer.node_element_buffer.iter() {
            println!("element_buffer: {} -> {}", k, v);
        }
        for (k, v) in data_buffer.edge_redirection.iter() {
            println!("edge_redirection: {} -> {}", k, v);
        }
        assert!(s.unwrap() == example_guardian);
        assert!(!data_buffer.edges_include_map.contains_key(&blanknode1));
        assert!(!data_buffer.edges_include_map.contains_key(&example_warden));
        print_graph_display_data(&data_buffer);
        println!("data_buffer: {}", data_buffer);
    }

    pub fn print_graph_display_data(data_buffer: &SerializationDataBuffer) {
        for (index, (element, label)) in data_buffer.node_element_buffer.iter().enumerate() {
            println!("{index}: {label} -> {element:?}");
        }
        for edge in data_buffer.edge_buffer.iter() {
            println!(
                "{} -> {:?} -> {}",
                edge.subject, edge.element_type, edge.object
            );
        }
    }
}
